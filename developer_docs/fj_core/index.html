<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Fornjot Core"><title>fj_core - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="fj_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../fj_core/index.html">fj_core</a><span class="version">0.49</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#fornjot-core" title="Fornjot Core">Fornjot Core</a><ul><li><a href="#design-principle" title="Design Principle">Design Principle</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>fj_core</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/fj_core/lib.rs.html#1-121">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="fornjot-core"><a class="doc-anchor" href="#fornjot-core">§</a>Fornjot Core</h2>
<p><a href="https://www.fornjot.app/">Fornjot</a> is an early-stage b-rep CAD kernel written in Rust. The kernel is
split into multiple libraries that can be used semi-independently, and this
is one of those.</p>
<p>This library defines geometric and topological primitives, and the
algorithms that operate on them.</p>
<h3 id="design-principle"><a class="doc-anchor" href="#design-principle">§</a>Design Principle</h3>
<p>The CAD kernel follows the design principle of <strong>robustness through
explicitness</strong>. This means that geometrical relationships must be expressed
explicitly, or they are not accepted.</p>
<p>This principle is not fully implemented yet. There are quite a few
validation checks that enforce part of it, but many are still missing.</p>
<h4 id="motivation"><a class="doc-anchor" href="#motivation">§</a>Motivation</h4>
<p>A problem that CAD kernels need to handle is the inherent fuzziness of
geometric relationships. Is a point on a curve, or just close to it? Does a
curve lie in a surface, or does it not? This is exacerbated by the limited
precision of numerical representations in computers, and especially the
inconvenient precision characteristics of floating-point numbers.</p>
<p>These problems can be addressed by always comparing numbers using an epsilon
value. Numbers that are very close together (their difference is smaller
than epsilon) are considered equal.</p>
<p>This approach has several problems:</p>
<ul>
<li>If the epsilon value is chosen too high, then very small models can become
buggy, as distinct geometry is merged together.</li>
<li>If the epsilon value is chosen too low, then very large models can become
buggy, as geometry that is supposed to be identical is recognized as
distinct.</li>
<li>These epsilon comparisons need to be used everywhere where numbers are
handled. It can be easy to forget this. Using custom wrapper types is
possible, but either inflexible (because the epsilon value is hardcoded)
or inconvenient (because the epsilon value needs to be provided).</li>
</ul>
<p>Choosing an epsilon value that is suitable for <em>most</em> use cases is possible,
at the cost of non-standard use cases breaking in unexpected and non-obvious
ways. Fornjot has chosen a different approach.</p>
<h4 id="explicitness"><a class="doc-anchor" href="#explicitness">§</a>Explicitness</h4>
<p>By requiring geometric relationships to be <em>explicit</em>, we don’t have to use
error-prone heuristics to determine those relationships. That means, for
example, two vertices that happen to be identical, or very close to each
other, are not accepted.</p>
<p>If vertex instances that refer to the same point are used in different
places (for example, in two neighboring edges that share a vertex), then
those vertex instances must be known by the system to refer to the same
vertex. If a vertex lies on an edge or in a surface, then it must be defined
in terms of its position on that edge or surface.</p>
<p>This can have consequences for how users define models. For example, if the
user moves two shapes close to each other, so they touch but don’t
intersect, this should lead to an error message, explaining to the user why
what they did is a problem, and teaching them how to define their model in
a different way, so the system knows the semantic relationships between
geometrical objects.</p>
<h4 id="validation"><a class="doc-anchor" href="#validation">§</a>Validation</h4>
<p>These rules of explicitness must be validated, so the user can know if there
is a problem in the model, and fix it. This is preferable to failing in
unexpected ways later on.</p>
<p>For the comparisons required for validation, an epsilon value must be used.
This epsilon value can be derived from the size of the model, and should be
chosen as high as possible, so any potential problems can be immediately
reported as errors.</p>
<p>If the user does something non-standard, they can override the epsilon value
on a per-shape basis. Forcing the user to deal with these issues up-front
should lead to less work overall.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="algorithms/index.html" title="mod fj_core::algorithms">algorithms</a></dt><dd>Collection of algorithms that operate on geometry</dd><dt><a class="mod" href="geometry/index.html" title="mod fj_core::geometry">geometry</a></dt><dd>Geometry that is applied to the topological object graph</dd><dt><a class="mod" href="layers/index.html" title="mod fj_core::layers">layers</a></dt><dd>Loosely coupled layers, that together define shapes</dd><dt><a class="mod" href="operations/index.html" title="mod fj_core::operations">operations</a></dt><dd>Create and modify shapes</dd><dt><a class="mod" href="presentation/index.html" title="mod fj_core::presentation">presentation</a></dt><dd>Presentation data for the object graph</dd><dt><a class="mod" href="queries/index.html" title="mod fj_core::queries">queries</a></dt><dd>Queries about objects</dd><dt><a class="mod" href="storage/index.html" title="mod fj_core::storage">storage</a></dt><dd>Append-only object storage</dd><dt><a class="mod" href="topology/index.html" title="mod fj_core::topology">topology</a></dt><dd>Objects of a shape</dd><dt><a class="mod" href="validate/index.html" title="mod fj_core::validate">validate</a></dt><dd>Infrastructure for validating objects</dd><dt><a class="mod" href="validation/index.html" title="mod fj_core::validation">validation</a></dt><dd>Infrastructure for validating objects</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.assert_contains_err.html" title="macro fj_core::assert_contains_err">assert_<wbr>contains_<wbr>err</a></dt><dd>Assert that some object has a validation error which matches a specific
pattern. This is preferred to matching on <a href="validate/trait.Validate.html#method.validate_and_return_first_error" title="method fj_core::validate::Validate::validate_and_return_first_error"><code>Validate::validate_and_return_first_error</code></a>, since usually we don’t care about the order.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Core.html" title="struct fj_core::Core">Core</a></dt><dd>An instance of the Fornjot core</dd></dl><script type="text/json" id="notable-traits-data">{"IntoIter<T, A>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/alloc/vec/into_iter/struct.IntoIter.html\" title=\"struct alloc::vec::into_iter::IntoIter\">IntoIter</a>&lt;T, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/alloc/vec/into_iter/struct.IntoIter.html\" title=\"struct alloc::vec::into_iter::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.89.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T;</div>","Iter<'_, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/slice/iter/struct.Iter.html\" title=\"struct core::slice::iter::Iter\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/slice/iter/struct.Iter.html\" title=\"struct core::slice::iter::Iter\">Iter</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.89.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;'a T</a>;</div>"}</script></section></div></main></body></html>